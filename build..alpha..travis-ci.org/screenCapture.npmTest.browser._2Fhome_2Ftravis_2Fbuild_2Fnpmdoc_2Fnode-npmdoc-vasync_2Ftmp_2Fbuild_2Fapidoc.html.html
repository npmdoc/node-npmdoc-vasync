<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/davepacheco/node-vasync#readme">vasync (v1.6.4)</a>
</h1>
<h4>utilities for observable asynchronous control flow</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.vasync">module vasync</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vasync.barrier">
            function <span class="apidocSignatureSpan">vasync.</span>barrier
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vasync.forEachParallel">
            function <span class="apidocSignatureSpan">vasync.</span>forEachParallel
            <span class="apidocSignatureSpan">(args, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vasync.forEachPipeline">
            function <span class="apidocSignatureSpan">vasync.</span>forEachPipeline
            <span class="apidocSignatureSpan">(args, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vasync.parallel">
            function <span class="apidocSignatureSpan">vasync.</span>parallel
            <span class="apidocSignatureSpan">(args, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vasync.pipeline">
            function <span class="apidocSignatureSpan">vasync.</span>pipeline
            <span class="apidocSignatureSpan">(args, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vasync.queue">
            function <span class="apidocSignatureSpan">vasync.</span>queue
            <span class="apidocSignatureSpan">(worker, concurrency)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vasync.queuev">
            function <span class="apidocSignatureSpan">vasync.</span>queuev
            <span class="apidocSignatureSpan">(args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.vasync.waterfall">
            function <span class="apidocSignatureSpan">vasync.</span>waterfall
            <span class="apidocSignatureSpan">(funcs, callback)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.vasync" id="apidoc.module.vasync">module vasync</a></h1>


    <h2>
        <a href="#apidoc.element.vasync.barrier" id="apidoc.element.vasync.barrier">
        function <span class="apidocSignatureSpan">vasync.</span>barrier
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function barrier(args)
{
	return (new Barrier(args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Example: printing sizes of files in a directory

```js
var mod_fs = require('fs');
var mod_path = require('path');
var mod_vasync = require('../lib/vasync');

var barrier = mod_vasync.<span class="apidocCodeKeywordSpan">barrier</span>();

barrier.on('drain', function () {
  console.log('all files checked');
});

barrier.start('readdir');
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vasync.forEachParallel" id="apidoc.element.vasync.forEachParallel">
        function <span class="apidocSignatureSpan">vasync.</span>forEachParallel
        <span class="apidocSignatureSpan">(args, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachParallel(args, callback)
{
	var func, funcs;

	mod_assert.equal(typeof (args), 'object', '"args" must be an object');
	mod_assert.equal(typeof (args['func']), 'function',
	    '"args.func" must be specified and must be a function');
	mod_assert.ok(Array.isArray(args['inputs']),
	    '"args.inputs" must be specified and must be an array');

	func = args['func'];
	funcs = args['inputs'].map(function (input) {
		return (function (subcallback) {
			return (func(input, subcallback));
		});
	});

	return (parallel({ 'funcs': funcs }, callback));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
This function is exactly like `parallel`, except that the input is specified as
a *single* function ("func") and a list of inputs ("inputs").  The function is
invoked on each input in parallel.

This example is exactly equivalent to the one above:

```js
console.log(mod_vasync.<span class="apidocCodeKeywordSpan">forEachParallel</span>({
    'func': mod_dns.resolve,
    'inputs': [ 'joyent.com', 'github.com', 'asdfaqsdfj.com' ]
}, function (err, results) {
    console.log('error: %s', err.message);
    console.log('results: %s', mod_util.inspect(results, null, 3));
}));
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vasync.forEachPipeline" id="apidoc.element.vasync.forEachPipeline">
        function <span class="apidocSignatureSpan">vasync.</span>forEachPipeline
        <span class="apidocSignatureSpan">(args, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEachPipeline(args, callback) {
    mod_assert.equal(typeof (args), 'object', '"args" must be an object');
    mod_assert.equal(typeof (args['func']), 'function',
		'"args.func" must be specified and must be a function');
    mod_assert.ok(Array.isArray(args['inputs']),
		'"args.inputs" must be specified and must be an array');
    mod_assert.equal(typeof (callback), 'function',
		'callback argument must be specified and must be a function');

    var func = args['func'];

    var funcs = args['inputs'].map(function (input) {
		return (function (_, subcallback) {
			return (func(input, subcallback));
		});
    });

    return (pipeline({'funcs': funcs}, callback));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
This function is exactly like `pipeline`, except that the input is specified as
a *single* function ("func") and a list of inputs ("inputs").  The function is
invoked on each input in series.

This example is exactly equivalent to the one above:

```js
console.log(mod_vasync.<span class="apidocCodeKeywordSpan">forEachPipeline</span>({
    'func': mod_dns.resolve,
    'inputs': [ 'joyent.com', 'github.com', 'asdfaqsdfj.com' ]
}, function (err, results) {
    console.log('error: %s', err.message);
    console.log('results: %s', mod_util.inspect(results, null, 3));
}));
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vasync.parallel" id="apidoc.element.vasync.parallel">
        function <span class="apidocSignatureSpan">vasync.</span>parallel
        <span class="apidocSignatureSpan">(args, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parallel(args, callback)
{
	var funcs, rv, doneOne, i;

	mod_assert.equal(typeof (args), 'object', '"args" must be an object');
	mod_assert.ok(Array.isArray(args['funcs']),
	    '"args.funcs" must be specified and must be an array');
	mod_assert.equal(typeof (callback), 'function',
	    'callback argument must be specified and must be a function');

	funcs = args['funcs'].slice(0);

	rv = {
	    'operations': new Array(funcs.length),
	    'successes': [],
	    'ndone': 0,
	    'nerrors': 0
	};

	if (funcs.length === 0) {
		setImmediate(function () { callback(null, rv); });
		return (rv);
	}

	doneOne = function (entry) {
		return (function (err, result) {
			mod_assert.equal(entry['status'], 'pending');

			entry['err'] = err;
			entry['result'] = result;
			entry['status'] = err ? 'fail' : 'ok';

			if (err)
				rv['nerrors']++;
			else
				rv['successes'].push(result);

			if (++rv['ndone'] &lt; funcs.length)
				return;

			var errors = rv['operations'].filter(function (ent) {
				return (ent['status'] == 'fail');
			}).map(function (ent) { return (ent['err']); });

			if (errors.length &gt; 0)
				callback(new mod_verror.MultiError(errors), rv);
			else
				callback(null, rv);
		});
	};

	for (i = 0; i &lt; funcs.length; i++) {
		rv['operations'][i] = {
			'func': funcs[i],
			'funcname': funcs[i].name || '(anon)',
			'status': 'pending'
		};

		funcs[i](doneOne(rv['operations'][i]));
	}

	return (rv);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

All errors are combined into a single "err" parameter to the final callback (see
below).

Example usage:

```js
console.log(mod_vasync.<span class="apidocCodeKeywordSpan">parallel</span>({
    'funcs': [
function f1 (callback) { mod_dns.resolve('joyent.com', callback); },
function f2 (callback) { mod_dns.resolve('github.com', callback); },
function f3 (callback) { mod_dns.resolve('asdfaqsdfj.com', callback); }
    ]
}, function (err, results) {
console.log('error: %s', err.message);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vasync.pipeline" id="apidoc.element.vasync.pipeline">
        function <span class="apidocSignatureSpan">vasync.</span>pipeline
        <span class="apidocSignatureSpan">(args, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pipeline(args, callback)
{
	var funcs, uarg, rv, next;

	mod_assert.equal(typeof (args), 'object', '"args" must be an object');
	mod_assert.ok(Array.isArray(args['funcs']),
	    '"args.funcs" must be specified and must be an array');

	funcs = args['funcs'].slice(0);
	uarg = args['arg'];

	rv = {
	    'operations': funcs.map(function (func) {
		return ({
		    'func': func,
		    'funcname': func.name || '(anon)',
		    'status': 'waiting'
		});
	    }),
	    'successes': [],
	    'ndone': 0,
	    'nerrors': 0
	};

	if (funcs.length === 0) {
		setImmediate(function () { callback(null, rv); });
		return (rv);
	}

	next = function (err, result) {
		if (rv['nerrors'] &gt; 0 ||
		    rv['ndone'] &gt;= rv['operations'].length) {
			throw new mod_verror.VError('pipeline callback ' +
			    'invoked after the pipeline has already ' +
			    'completed (%j)', rv);
		}

		var entry = rv['operations'][rv['ndone']++];

		mod_assert.equal(entry['status'], 'pending');

		entry['status'] = err ? 'fail' : 'ok';
		entry['err'] = err;
		entry['result'] = result;

		if (err)
			rv['nerrors']++;
		else
			rv['successes'].push(result);

		if (err || rv['ndone'] == funcs.length) {
			callback(err, rv);
		} else {
			var nextent = rv['operations'][rv['ndone']];
			nextent['status'] = 'pending';

			<span class="apidocCodeCommentSpan">/*
			 * We invoke the next function on the next tick so that
			 * the caller (stage N) need not worry about the case
			 * that the next stage (stage N + 1) runs in its own
			 * context.
			 */
</span>			setImmediate(function () {
				nextent['func'](uarg, next);
			});
		}
	};

	rv['operations'][0]['status'] = 'pending';
	funcs[0](uarg, next);

	return (rv);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
for `parallel`.  The error object for the final callback is just the error
returned by whatever pipeline function failed (if any).

This example is similar to the one above, except that it runs the steps in
sequence and stops early because `pipeline` stops on the first error:

```js
console.log(mod_vasync.<span class="apidocCodeKeywordSpan">pipeline</span>({
    'funcs': [
function f1 (_, callback) { mod_fs.stat('/tmp', callback); },
function f2 (_, callback) { mod_fs.stat('/noexist', callback); },
function f3 (_, callback) { mod_fs.stat('/var', callback); }
    ]
}, function (err, results) {
console.log('error: %s', err.message);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vasync.queue" id="apidoc.element.vasync.queue">
        function <span class="apidocSignatureSpan">vasync.</span>queue
        <span class="apidocSignatureSpan">(worker, concurrency)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queue(worker, concurrency)
{
	return (new WorkQueue({
	    'worker': worker,
	    'concurrency': concurrency
	}));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

function doneOne()
{
  console.log('task completed; queue state:\n%s\n',
      JSON.stringify(queue, null, 4));
}

queue = mod_vasync.<span class="apidocCodeKeywordSpan">queue</span>(mod_fs.stat, 2);

console.log('initial queue state:\n%s\n', JSON.stringify(queue, null, 4));

queue.push('/tmp/file1', doneOne);
queue.push('/tmp/file2', doneOne);
queue.push('/tmp/file3', doneOne);
queue.push('/tmp/file4', doneOne);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vasync.queuev" id="apidoc.element.vasync.queuev">
        function <span class="apidocSignatureSpan">vasync.</span>queuev
        <span class="apidocSignatureSpan">(args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function queuev(args)
{
	return (new WorkQueue(args));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.vasync.waterfall" id="apidoc.element.vasync.waterfall">
        function <span class="apidocSignatureSpan">vasync.</span>waterfall
        <span class="apidocSignatureSpan">(funcs, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function waterfall(funcs, callback)
{
	var rv, current, next;

	mod_assert.ok(Array.isArray(funcs));
	mod_assert.ok(arguments.length == 1 || typeof (callback) == 'function');
	funcs = funcs.slice(0);

	rv = {
	    'operations': funcs.map(function (func) {
	        return ({
		    'func': func,
		    'funcname': func.name || '(anon)',
		    'status': 'waiting'
		});
	    }),
	    'successes': [],
	    'ndone': 0,
	    'nerrors': 0
	};

	if (funcs.length === 0) {
		if (callback)
			setImmediate(function () { callback(null, rv); });
		return (rv);
	}

	next = function (idx, err) {
		var args, entry, nextentry;

		if (err === undefined)
			err = null;

		if (idx != current) {
			throw (new mod_verror.VError(
			    'vasync.waterfall: function %d ("%s") invoked ' +
			    'its callback twice', idx,
			    rv['operations'][idx].funcname));
		}

		mod_assert.equal(idx, rv['ndone']);
		entry = rv['operations'][rv['ndone']++];
		args = Array.prototype.slice.call(arguments, 2);

		mod_assert.equal(entry['status'], 'pending');
		entry['status'] = err ? 'fail' : 'ok';
		entry['err'] = err;
		entry['results'] = args;

		if (err)
			rv['nerrors']++;
		else
			rv['successes'].push(args);

		if (err || rv['ndone'] == funcs.length) {
			if (callback) {
				args.unshift(err);
				callback.apply(null, args);
			}
		} else {
			nextentry = rv['operations'][rv['ndone']];
			nextentry['status'] = 'pending';
			current++;
			args.push(next.bind(null, current));
			setImmediate(function () {
				nextentry['func'].apply(null, args);
			});
		}
	};

	rv['operations'][0]['status'] = 'pending';
	current = 0;
	funcs[0](next.bind(null, current));
	return (rv);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
to each function in the chain.  pipeline() always passes the same argument
followed by the callback, while waterfall() passes whatever values were emitted
by the previous function followed by the callback.

Here's an example:

```js
mod_vasync.<span class="apidocCodeKeywordSpan">waterfall</span>([
    function func1(callback) {
 	setImmediate(function () {
		callback(null, 37);
	});
    },
    function func2(extra, callback) {
	console.log('func2 got "%s" from func1', extra);
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>